## 内网 RTT

在内网，1KB 的 packet RTT 通常在 100~300 microsecond 左右。

```c++
// server
int main(int argc, char *argv[]) {
        constexpr int MAXLINE = 1024;

        int endp = socket(AF_INET, SOCK_STREAM, 0);
        if (endp < 0) {
                perror("socket");
                return EXIT_FAILURE;
        }
        sockaddr_in saddr;
        bzero(&saddr, sizeof(saddr));
        saddr.sin_family = AF_INET;
        saddr.sin_addr.s_addr = htonl(INADDR_ANY);
        saddr.sin_port = htons(8080);
        if (bind(endp, (sockaddr *) &saddr, sizeof(saddr)) < 0) {
                perror("bind");
                return EXIT_FAILURE;
        }
        if (listen(endp, 10) < 0) {
                perror("listen");
                return EXIT_FAILURE;
        }

        for (int i = 0; i < 1; i++) {
                sockaddr_in caddr;
                socklen_t cl = sizeof(caddr);
                int conn = accept(endp, (sockaddr *) &caddr, &cl);
                if (conn < 0) {
                        perror("accept");
                        return EXIT_FAILURE;
                }

                char buf[MAXLINE + 1];
                ssize_t il, ol;
                while ((il = read(conn, buf, MAXLINE)) > 0) {
                        ssize_t nw = 0;
                        while (nw < il) {
                                ssize_t n = write(conn, buf + nw, il - nw);
                                if (n < 0) {
                                        perror("write");
                                        break;
                                }
                                if (n < il - nw) {
                                        cout << "server write extra round trip" << endl;
                                }
                                nw += n;
                        }
                        buf[il] = '\0';
                }
                close(conn);
        }
        close(endp);
        return EXIT_SUCCESS;
}
```

```c++
// client
int main(int argc, char *argv[]) {
        constexpr int MAXLINE = 1024;

        int sk = socket(AF_INET, SOCK_STREAM, 0);
        if (sk < 0) {
                perror("socket");
                return EXIT_FAILURE;
        }
        sockaddr_in saddr;
        bzero(&saddr, sizeof(saddr));
        saddr.sin_family = AF_INET;
        if (inet_pton(AF_INET, argv[1], &saddr.sin_addr) <= 0) {
                perror("inet_pton");
                return EXIT_FAILURE;
        }
        saddr.sin_port = htons(8080);
        if (connect(sk, (sockaddr *) &saddr, sizeof(saddr)) < 0) {
                perror("connect");
                return EXIT_FAILURE;
        }

        for (int i = 0; i < 10; i++) {
                char buf[MAXLINE];
                for (int i = 0; i < sizeof(buf); i++) {
                        buf[i] = rand() % 10 + '0';
                }

                auto t1 = chrono::steady_clock::now();
                ssize_t nw = 0;
                while (nw < MAXLINE) {
                        ssize_t n = write(sk, buf + nw, MAXLINE - nw);
                        if (n < 0) {
                                perror("write");
                                return EXIT_FAILURE;
                        }
                        if (n < MAXLINE - nw) {
                                cout << "client write extra round trip" << endl;
                        }
                        nw += n;
                }

                ssize_t nr = 0;
                while (nr < MAXLINE) {
                        ssize_t n = read(sk, buf + nr, MAXLINE - nr);
                        //cout << "client read " << n << endl;
                        if (n < 0) {
                                perror("read");
                                return EXIT_FAILURE;
                        }
                        if (n < MAXLINE - nr) {
                                cout << "client read extra round trip" << endl;
                        }
                        nr += n;
                }
                auto t2 = chrono::steady_clock::now();
                cout << "round-trip time: " << chrono::duration_cast<chrono::microseconds>(t2 - t1).count() << endl;
        }

        close(sk);
        return EXIT_SUCCESS;
}
```

## SSD 随机读写 1KB

